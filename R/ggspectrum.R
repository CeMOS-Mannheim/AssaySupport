.convertSpec <- function(spec, ID, plotIdx) {
  if(!length(ID)==1) {
    stop("Length of name has to be one.\n")
  }
  if(isMassPeaks(spec)) {
    df <- tibble::tibble(ID = ID, 
                         plotIdx = plotIdx,
                         mz = mass(spec), 
                         int = intensity(spec), 
                         SNR = snr(spec),
                         type = "peak")
  } else if (isMassSpectrum(spec) || isMassSpectrumOnDisk(spec)) {
    df <- tibble::tibble(ID = ID, 
                         plotIdx = plotIdx,
                         mz = mass(spec), 
                         int = intensity(spec),
                         type = "spectrum")
  } else if(is.list(spec)) {
    stop("spec was a list. Has to be a single (MALDIquant) object.\n")
  } else {
    stop("spec was no valid MALDIquant object.\n")
  }
  return(df)
}

#' Convert MALDIquant::MassSpectrum to tibble
#'
#' @param spec              (list of) MALDIquant::MassSpectrum 
#' @param peaks             (list of) MALDIquant::MassPeaks. Optinal. 
#' @param nameFromMetaData  Logical, get names from metaData or from named list.
#'
#' @return
#' tibble with spectra and peak data.
#' @export
spec2df <- function(spec, peaks, nameFromMetaData = FALSE) {
  if(!missing(peaks)) {
    if(MALDIquant:::.isMassObjectList(spec)) {
      if(!length(spec) == length(peaks)) {
        stop("Length of spec and peaks does not match!\n")
      }
    } 
  }
  
  
  noNames <- FALSE
  if(nameFromMetaData) {
    if(is.list(spec)) {
      names <- vapply(spec, function(x) {
        md <- metaData(x)
        nm <- md[[grep("name", names(md))]]
        return(nm)
      }, "a")
    } else {
      md <- metaData(spec)
      names <- md[[grep("name", names(md))]]
    }
    
    if(any(is.na(names))) {
      noNames <- TRUE
    }
  } else if(!is.null(names(spec))) {
    names <- names(spec)
  } else {
    noNames <- TRUE
  }
  
  if(noNames) {
    warning("spectra were not named, no IDs assigned!\n")
    if(is.list(spec)) {
      names <- rep(NA, length(spec))
    } else {
      names <- NA
    }
  }
  if(is.list(spec)) {
    df_spec <- lapply(1:length(spec), function(i) {
      return(AssaySupport:::.convertSpec(spec[[i]], names[[i]], i))
    })
  } else {
    df_spec <- AssaySupport:::.convertSpec(spec, names[1], 1)
  }
  
  if(!missing(peaks)) {
    if(is.list(peaks)) {
      df_peaks <- lapply(1:length(spec), function(i) {
        return(AssaySupport:::.convertSpec(peaks[[i]], names[[i]], i))
      })
      
    } else {
      df_peaks <- AssaySupport:::.convertSpec(peaks, names[1], 1)
    }
    df <- bind_rows(df_spec, df_peaks)
  } else {
    df <- df_spec
  }
  return(df)
}

#' ggplot wrapper to plot spectra
#'
#' @param df      tibble, as generated by spec2df()
#' @param minSNR  numeric, filter peaks with snr lower then minSNR.
#' @param scale   numeric or character, either numeric to multiply intensity or "min" or "max" to scale spectra to specified measure.
#' @param round   integer, number of digits to display in plot.
#'
#' @return
#' ggplot object.
#' @export
ggSpectrum <- function(df, minSNR = 1, scale = 100, round = 1) {
  if(is.numeric(scale)) {
    df$int <- df$int * 100
  } else switch (scale,
                 max = df <- df %>%
                   group_by(ID) %>%
                   mutate(int = int/max(int)),
                 min = df <- df %>%
                   group_by(ID) %>%
                   mutate(int = int/min(int))
  )
  
  if("SNR" %in% colnames(df)) {
    df <- df %>%
      mutate(label = ifelse(!is.na(SNR), round(mz, round), NA))
    peakdf <- df %>%
      filter(!is.na(label)) %>%
      filter(SNR > minSNR) %>%
      group_by(mz) %>%
      arrange(desc(int)) %>%
      summarise(int = first(int),
                label = first(label),
                ID = first(ID))
  }
  
  
  if(all(is.na(df$ID))) {
    p <- ggplot(df, aes(x = mz, y = int)) 
    
  } else {
    p <- ggplot(df, aes(x = mz, y = int, col = ID)) 
  }
  
  p <- p +
    geom_line() +
    theme(legend.position = "bottom")
  
  if("SNR" %in% colnames(df)) {
    p <- p +
      geom_point(data = peakdf, aes(x = mz, y = int), col = "black") +
      ggrepel::geom_text_repel(data = peakdf, aes(x = mz, y = int, label = label),
                               segment.colour = "grey", 
                               min.segment.length = 0, 
                               col = "black") 
  }
  return(p)
}


